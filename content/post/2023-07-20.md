# Item 4

## 인스턴스화를 막으려거든 private 생성자를 사용해라

- 정적 메소드와 정적 필드만을 담은 유틸리티 클래스를 만드는 경우가 존재 가능
  - `java.lang.Math` 혹은 `java.util.Arrays`와 같이 primitive type 혹은 배열을 다루는 메서드들을 모아 놓는 클래스
  - `java.util.Collections` 처럼 인터페이스를 구현하는 정적 메서드들로 구성된 클래스
  - `final` 클래스에 관련된 메서드들을 모아 둔 클래스
- 이런 유틸리티 클래스에서 생성자를 명시하지 않게 되면, 기본 생성자가 만들어 짐
  - 매개변수를 받지 않는 `public` 생성자
  - 즉, 인스턴스화를 할 수 있게 됨
- 추상 클래스로 만든다고 인스턴스화가 막히는 것은 아님
  - 하위 클래스를 만들어서 상속받은 후 인스턴스화를 진행하면 되기 때문
- 따라서 이렇게 인스턴스화를 막아야 하는 유틸리티 클래스는 private 생성자를 추가하면 됨

## 참고 사항

- private 생성자이므로, 외부에서는 호출할 수 없게 됨
- 그러나 내부에서 실수로 호출하거나, reflection API 등을 이용한 생성자 호출을 할 수도 있음
  - 이런 경우를 막기 위해 `AssertionError`를 던져주면, 인스턴스화가 되지 않음
  - 이 경우는 코드가 직관적이지 않으므로 적절한 주석으로 설명해 두는 것도 좋은 방법
- 또한 private 생성자가 있는 경우 상속이 불가능해짐
  - 하위 클래스는 상위 클래스의 생성자를 호출해야 하므로

```Java
class SomeUtilClass {

    // 인스턴스화 방지를 위해 기본 생성자가 만들어 지는 것을 막는다
    private SomeUtilClass() {
        throw new AssertionError();
    }
}
```

## References

1. 조슈아 블로크 - Effective Java 3/E
