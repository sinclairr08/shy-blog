---
title: "2023-07-28 TIL"
date: 2023-07-28
---

# 2023-07-28 TIL

### 백엔드 개발자를 위한 보안 강의

- 시큐어 코딩
  - 버그 없는 서비스는 없음, 언어, 플랫폼, 환경에 종속
  - 모든 버그를 프레임워크가 다 해결해주지는 않음, 보안 버그에 대해 잘 알 필요가 있음
- XSS
  - 특정 페이지에 공격자가 임의의 코드를 삽입해서 원하는 코드를 실행시키는 형태
  - 개발자가 할 수 있는 모든 행위를 할 수 있음, 쿠키 및 세션을 탈취해 사용자의 계정을 탈취 가능
  - Reflected XSS
    - 사용자가 어떤 값을 입력하면 해당 값이 응답 페이지에서 실행되는 취약점
    - 최근 많이 사용하는 Shorten URL이 위험
  - Stored XSS
    - 공격자가 코드를 게시글 등에 저장해 두고, 다른 사람이 해당 글을 볼 때 실행되는 취약점
  - DOM-Based XSS
    - URL 주소의 해쉬값을 처리하는 과정에서 발생하는 취약점
  - Universal XSS
    - 브라우저 취약점으로 인해 불특정 사이트에 XSS 공격하는 취약점
  - 대응 방안
    - XSS Escape: 사용자 입력한 값을 그대로 실행하면 문제가 되므로, `<`, `>`등 특수 문자를 치환. 많은 템플릿 엔진에서 기본적으로 지원
    - XSS Sanitize: DOM을 분석해서 공격 페이로드를 삭제하는 방법, luxy-xss-servlet-filter 등 라이브러리를 가져와서 사용
    - 보안 헤더 적용: XSS 취약점이 존재하더라도, `Content-Security-Policy` header를 통해 삽입된 스크립트를 실행하지 않을 수 있음
    - Content-Type 명시: Content-type이 `text/html`이 아닌 경우, 스크립트가 실행되지 않음
  - 잘못된 대응 방안: 정규식으로 script 등을 치환하는 방법으로 막으려는 경우가 있는데, 다음과 같이 우회 가능
    - scr**script**ipt
- SQL Injection
  - 서비스 DB Query에 공격자 구문이 삽입된 채 실행되는 보안 취약점
  - 정적인 쿼리는 prepared statement 사용
  - 동적인 쿼리는 엄격한 검사 (in, ORDER BY 등이 들어가 있지 않은지)
  - 가장 중요하고 좋은 방법은 데이터 자체를 암호화 하는 것
- Server Side Request Forgery
  - 공격자가 서버에서 이루어지는 요청을 변조해, 다른 임의의 서버로 요청을 보내는 취약점
  - 공격자가 타인의 인증 정보를 이용해 외부 서버에 요청을 보낼 수 있게 되면, 굉장히 심각한 계정 탈취 문제!
- Business Logic Vulnerability
  - 로직에 결함이 존재해, 개발자가 의도하지 않은 흐름으로 처리되는 보안 이슈
  - Front 나 앱에서는 검증하고, 서버에서 검증하지 않아서 문제가 발생할 수 있음
  - 모든 단계에서 검증을 수행하고, 사용자의 입력 값을 절대 신뢰하지 말기

### 암호학 개론 강의

- 암호: 단방향(Hash)과 양방향(대칭키, 공개키) 암호 존재
- 고전 암호화 기법
  - 혼돈: 문자를 다른 문자로
  - 확산: 문자들의 순서를 변경
- AES와 같은 최신 알고리즘은 키를 통해 데이터를 암호화
- 대칭키 알고리즘 → 키 하나만을 사용하여 공유하고, 암호화 및 복호화를 수행
- ECB 모드로 암호화하면, 입력값에 따른 결과값이 deterministic함 (사용 금지!)
  - 이 모드의 문제를 해결하기 위해 CBC, CTR, GCM(최신) 등의 운영 모드 사용
- AES: Advanced Encryption Standard
  - 전수조사에 취약한 DES를 대체
  - 128비트 이상
- nClavis에 노출되면 안되는 정보나 키 등을 저장 가능
- 공개키 알고리즘: 비대칭키 알고리즘
  - 페르마 소정리 이용, 소인수분해의 어려움을 이용
  - 기밀성 및 부인 방지 기능 제공
- HTTPS는 handshaking 과정에서 RSA 사용
  - 브라우저는 비밀 키를 만듦
  - 서버의의 공개 키로 암호화해서 서버에 전송
  - 서버는 개인 키로 브라우저의 비밀 키를 알게 됨
  - 이 비밀키를 KDF를 통해 암호화 후, 서버는 대칭키를 만듦
  - 동일한 KDF를 통해 브라우저 역시 대칭키를 가지게 됨
  - KDF는 negotiation을 통해 정해짐
  - 이후 대칭키를 통해 데이터를 빠르게 암호화해서 전송 가능
- 이외에도 여러 대칭키 알고리즘이 존재하지만, 대부분 RSA-2048 사용
- 해시: 공개된 단방향 함수로, 키가 사용되지 않음
  - 역상 저항성: 원문을 구하는 게 힘듦
  - 제2 역상 저항성: 한 해시값에 대해 같은 해시값을 가지는 원문을 찾기 힘듦
  - 충돌 저항성: 같은 해시값을 가지는 서로 다른 두 원문을 찾기 힘듦
  - MD5 / SHA-1 등은 취약점이 발견됨
  - 그래서 최근에는 암호학적 성질이 필요할 땐 SHA-2 SHA-3 등을 사용
- PBKDF2: 비밀번호 저장에 최적화, 한 번 해시를 수행할 때 시간이 굉장히 지연됨
- 전자 서명: 서명을 디지털로 함
  - 전자적인 ID 카드, 전자 서명의 유효성을 확인 가능
  - 서버 클라이언트가 아닌, 인증 기관 (CA)이 필요
  - 서명에는 공개키가 사용, 개인키를 통해 서명한 사람만 복호화 가능
- 결론
  - 대칭키에는 AES-128 이상 사용
  - 공개키에는 RSA-2048를 주로 사용
  - 해시에는 SHA-2, SHA-3
  - ECB 사용 금지
